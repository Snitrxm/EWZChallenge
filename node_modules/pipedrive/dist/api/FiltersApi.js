"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ApiClient = _interopRequireDefault(require("../ApiClient"));

var _AddFilterRequest = _interopRequireDefault(require("../model/AddFilterRequest"));

var _FilterType = _interopRequireDefault(require("../model/FilterType"));

var _FiltersBulkDeleteResponse = _interopRequireDefault(require("../model/FiltersBulkDeleteResponse"));

var _FiltersBulkGetResponse = _interopRequireDefault(require("../model/FiltersBulkGetResponse"));

var _FiltersDeleteResponse = _interopRequireDefault(require("../model/FiltersDeleteResponse"));

var _FiltersGetResponse = _interopRequireDefault(require("../model/FiltersGetResponse"));

var _FiltersPostResponse = _interopRequireDefault(require("../model/FiltersPostResponse"));

var _UpdateFilterRequest = _interopRequireDefault(require("../model/UpdateFilterRequest"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
* Filters service.
* @module api/FiltersApi
* @version 1.0.0
*/
var FiltersApi = /*#__PURE__*/function () {
  /**
  * Constructs a new FiltersApi. 
  * @alias module:api/FiltersApi
  * @class
  * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
  * default to {@link module:ApiClient#instance} if unspecified.
  */
  function FiltersApi(apiClient) {
    (0, _classCallCheck2["default"])(this, FiltersApi);
    this.apiClient = apiClient || _ApiClient["default"].instance;
  }
  /**
   * Add a new filter
   * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with 'AND', and only two second level condition groups are supported of which one must be glued with 'AND' and the second with 'OR'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
   * @param {Object} opts Optional parameters
   * @param {module:model/AddFilterRequest} opts.addFilterRequest 
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FiltersPostResponse} and HTTP response
   */


  (0, _createClass2["default"])(FiltersApi, [{
    key: "addFilterWithHttpInfo",
    value: function addFilterWithHttpInfo(opts) {
      opts = opts || {};
      var postBody = opts['addFilterRequest'];

      if (opts['name'] === undefined || opts['name'] === null) {
        throw new Error("Missing the required parameter 'name' when calling addFilter");
      }

      if (opts['conditions'] === undefined || opts['conditions'] === null) {
        throw new Error("Missing the required parameter 'conditions' when calling addFilter");
      }

      if (opts['type'] === undefined || opts['type'] === null) {
        throw new Error("Missing the required parameter 'type' when calling addFilter");
      }

      var pathParams = {};
      var queryParams = {};
      var headerParams = {};
      var formParams = {};
      var formParamArray = [];
      var contentTypes = ['application/json'];
      var isURLEncoded = contentTypes.includes('application/x-www-form-urlencoded');
      var isJSON = contentTypes.includes('application/json');

      if (isJSON) {
        postBody = _objectSpread(_objectSpread({}, postBody), opts);
      } else if (isURLEncoded) {
        for (var key in opts) {
          if (opts.hasOwnProperty(key) && !formParamArray.includes(key)) {
            formParams[key] = opts[key];
          }
        }
      }

      var authNames = ['api_key', 'oauth2'];
      var accepts = ['application/json'];
      var returnType = _FiltersPostResponse["default"];
      return this.apiClient.callApi('/filters', 'POST', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Add a new filter
     * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with 'AND', and only two second level condition groups are supported of which one must be glued with 'AND' and the second with 'OR'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
     * @param {Object} opts Optional parameters
     * @param {module:model/AddFilterRequest} opts.addFilterRequest 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FiltersPostResponse}
     */

  }, {
    key: "addFilter",
    value: function addFilter(opts) {
      return this.addFilterWithHttpInfo(opts).then(function (response_and_data) {
        return response_and_data;
      });
    }
    /**
     * Delete a filter
     * Marks a filter as deleted.
     * @param {Number} id The ID of the filter
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FiltersDeleteResponse} and HTTP response
     */

  }, {
    key: "deleteFilterWithHttpInfo",
    value: function deleteFilterWithHttpInfo(id) {
      var opts = {};
      var postBody = null; // verify the required parameter 'id' is set

      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteFilter");
      }

      var pathParams = {
        'id': id
      };
      var queryParams = {};
      var headerParams = {};
      var formParams = {};
      var formParamArray = [];
      var contentTypes = [];
      var isURLEncoded = contentTypes.includes('application/x-www-form-urlencoded');
      var isJSON = contentTypes.includes('application/json');

      if (isJSON) {
        postBody = _objectSpread(_objectSpread({}, postBody), opts);
      } else if (isURLEncoded) {
        for (var key in opts) {
          if (opts.hasOwnProperty(key) && !formParamArray.includes(key)) {
            formParams[key] = opts[key];
          }
        }
      }

      var authNames = ['api_key', 'oauth2'];
      var accepts = ['application/json'];
      var returnType = _FiltersDeleteResponse["default"];
      return this.apiClient.callApi('/filters/{id}', 'DELETE', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Delete a filter
     * Marks a filter as deleted.
     * @param {Number} id The ID of the filter
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FiltersDeleteResponse}
     */

  }, {
    key: "deleteFilter",
    value: function deleteFilter(id) {
      return this.deleteFilterWithHttpInfo(id).then(function (response_and_data) {
        return response_and_data;
      });
    }
    /**
     * Delete multiple filters in bulk
     * Marks multiple filters as deleted.
     * @param {String} ids The comma-separated filter IDs to delete
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FiltersBulkDeleteResponse} and HTTP response
     */

  }, {
    key: "deleteFiltersWithHttpInfo",
    value: function deleteFiltersWithHttpInfo(ids) {
      var opts = {};
      var postBody = null; // verify the required parameter 'ids' is set

      if (ids === undefined || ids === null) {
        throw new Error("Missing the required parameter 'ids' when calling deleteFilters");
      }

      var pathParams = {};
      var queryParams = {
        'ids': ids
      };
      var headerParams = {};
      var formParams = {};
      var formParamArray = [];
      var contentTypes = [];
      var isURLEncoded = contentTypes.includes('application/x-www-form-urlencoded');
      var isJSON = contentTypes.includes('application/json');

      if (isJSON) {
        postBody = _objectSpread(_objectSpread({}, postBody), opts);
      } else if (isURLEncoded) {
        for (var key in opts) {
          if (opts.hasOwnProperty(key) && !formParamArray.includes(key)) {
            formParams[key] = opts[key];
          }
        }
      }

      var authNames = ['api_key', 'oauth2'];
      var accepts = ['application/json'];
      var returnType = _FiltersBulkDeleteResponse["default"];
      return this.apiClient.callApi('/filters', 'DELETE', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Delete multiple filters in bulk
     * Marks multiple filters as deleted.
     * @param {String} ids The comma-separated filter IDs to delete
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FiltersBulkDeleteResponse}
     */

  }, {
    key: "deleteFilters",
    value: function deleteFilters(ids) {
      return this.deleteFiltersWithHttpInfo(ids).then(function (response_and_data) {
        return response_and_data;
      });
    }
    /**
     * Get one filter
     * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
     * @param {Number} id The ID of the filter
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FiltersGetResponse} and HTTP response
     */

  }, {
    key: "getFilterWithHttpInfo",
    value: function getFilterWithHttpInfo(id) {
      var opts = {};
      var postBody = null; // verify the required parameter 'id' is set

      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getFilter");
      }

      var pathParams = {
        'id': id
      };
      var queryParams = {};
      var headerParams = {};
      var formParams = {};
      var formParamArray = [];
      var contentTypes = [];
      var isURLEncoded = contentTypes.includes('application/x-www-form-urlencoded');
      var isJSON = contentTypes.includes('application/json');

      if (isJSON) {
        postBody = _objectSpread(_objectSpread({}, postBody), opts);
      } else if (isURLEncoded) {
        for (var key in opts) {
          if (opts.hasOwnProperty(key) && !formParamArray.includes(key)) {
            formParams[key] = opts[key];
          }
        }
      }

      var authNames = ['api_key', 'oauth2'];
      var accepts = ['application/json'];
      var returnType = _FiltersGetResponse["default"];
      return this.apiClient.callApi('/filters/{id}', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Get one filter
     * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
     * @param {Number} id The ID of the filter
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FiltersGetResponse}
     */

  }, {
    key: "getFilter",
    value: function getFilter(id) {
      return this.getFilterWithHttpInfo(id).then(function (response_and_data) {
        return response_and_data;
      });
    }
    /**
     * Get all filter helpers
     * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object} and HTTP response
     */

  }, {
    key: "getFilterHelpersWithHttpInfo",
    value: function getFilterHelpersWithHttpInfo() {
      var opts = {};
      var postBody = null;
      var pathParams = {};
      var queryParams = {};
      var headerParams = {};
      var formParams = {};
      var formParamArray = [];
      var contentTypes = [];
      var isURLEncoded = contentTypes.includes('application/x-www-form-urlencoded');
      var isJSON = contentTypes.includes('application/json');

      if (isJSON) {
        postBody = _objectSpread(_objectSpread({}, postBody), opts);
      } else if (isURLEncoded) {
        for (var key in opts) {
          if (opts.hasOwnProperty(key) && !formParamArray.includes(key)) {
            formParams[key] = opts[key];
          }
        }
      }

      var authNames = ['api_key'];
      var accepts = ['application/json'];
      var returnType = Object;
      return this.apiClient.callApi('/filters/helpers', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Get all filter helpers
     * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object}
     */

  }, {
    key: "getFilterHelpers",
    value: function getFilterHelpers() {
      return this.getFilterHelpersWithHttpInfo().then(function (response_and_data) {
        return response_and_data;
      });
    }
    /**
     * Get all filters
     * Returns data about all filters.
     * @param {Object} opts Optional parameters
     * @param {module:model/FilterType} opts.type The types of filters to fetch
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FiltersBulkGetResponse} and HTTP response
     */

  }, {
    key: "getFiltersWithHttpInfo",
    value: function getFiltersWithHttpInfo(opts) {
      opts = opts || {};
      var postBody = null;
      var pathParams = {};
      var queryParams = {
        'type': opts['type']
      };
      var headerParams = {};
      var formParams = {};
      var formParamArray = [];
      var contentTypes = [];
      var isURLEncoded = contentTypes.includes('application/x-www-form-urlencoded');
      var isJSON = contentTypes.includes('application/json');

      if (isJSON) {
        postBody = _objectSpread(_objectSpread({}, postBody), opts);
      } else if (isURLEncoded) {
        for (var key in opts) {
          if (opts.hasOwnProperty(key) && !formParamArray.includes(key)) {
            formParams[key] = opts[key];
          }
        }
      }

      var authNames = ['api_key', 'oauth2'];
      var accepts = ['application/json'];
      var returnType = _FiltersBulkGetResponse["default"];
      return this.apiClient.callApi('/filters', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Get all filters
     * Returns data about all filters.
     * @param {Object} opts Optional parameters
     * @param {module:model/FilterType} opts.type The types of filters to fetch
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FiltersBulkGetResponse}
     */

  }, {
    key: "getFilters",
    value: function getFilters(opts) {
      return this.getFiltersWithHttpInfo(opts).then(function (response_and_data) {
        return response_and_data;
      });
    }
    /**
     * Update filter
     * Updates an existing filter.
     * @param {Number} id The ID of the filter
     * @param {Object} opts Optional parameters
     * @param {module:model/UpdateFilterRequest} opts.updateFilterRequest 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FiltersPostResponse} and HTTP response
     */

  }, {
    key: "updateFilterWithHttpInfo",
    value: function updateFilterWithHttpInfo(id, opts) {
      opts = opts || {};
      var postBody = opts['updateFilterRequest']; // verify the required parameter 'id' is set

      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateFilter");
      }

      if (opts['conditions'] === undefined || opts['conditions'] === null) {
        throw new Error("Missing the required parameter 'conditions' when calling updateFilter");
      }

      var pathParams = {
        'id': id
      };
      var queryParams = {};
      var headerParams = {};
      var formParams = {};
      var formParamArray = [];
      var contentTypes = ['application/json'];
      var isURLEncoded = contentTypes.includes('application/x-www-form-urlencoded');
      var isJSON = contentTypes.includes('application/json');

      if (isJSON) {
        postBody = _objectSpread(_objectSpread({}, postBody), opts);
      } else if (isURLEncoded) {
        for (var key in opts) {
          if (opts.hasOwnProperty(key) && !formParamArray.includes(key)) {
            formParams[key] = opts[key];
          }
        }
      }

      var authNames = ['api_key', 'oauth2'];
      var accepts = ['application/json'];
      var returnType = _FiltersPostResponse["default"];
      return this.apiClient.callApi('/filters/{id}', 'PUT', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null);
    }
    /**
     * Update filter
     * Updates an existing filter.
     * @param {Number} id The ID of the filter
     * @param {Object} opts Optional parameters
     * @param {module:model/UpdateFilterRequest} opts.updateFilterRequest 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FiltersPostResponse}
     */

  }, {
    key: "updateFilter",
    value: function updateFilter(id, opts) {
      return this.updateFilterWithHttpInfo(id, opts).then(function (response_and_data) {
        return response_and_data;
      });
    }
  }]);
  return FiltersApi;
}();

exports["default"] = FiltersApi;